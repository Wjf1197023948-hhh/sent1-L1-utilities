function imgDeramp = topsDeramping( img, pars )
% Apply TOPS deramping in azimuth to an input Sentinel-1 IW/EW SLC image.
%
% Input:
%   - img: data array for IW/EW image, organized as a stack of burst images
%       with dimensions [Nrg, Naz, Nb], where 'Nrg' is the number of range
%       samples, 'Naz' is the number of lines and 'Nb' is the number of burst
%       images.
%   - pars: parameters structure for TOPS deramping, see Additional information.
%
% Outputs:
%   - imgDeramp: deramped IW/EW image, with the same dimensions as the input
%       image array.
%
% Required functions (not part of MATLAB): none
%
% Additional information:
%   TOPS deramping for Sentinel-1 IW/EW SLC images is described in Technical
%   Note COPE-GSEG-EOPG-TN-14-0025, entitled "Definition of the TOPS SLC
%   deramping function for products generated by the S-1 IPF" and available on
%   European Space Agency's website.
%
%   The input parameters structure for TOPS deramping "pars" should contain the
%   following fields:
%   - wl: signal's carrier wavelength [m];
%   - Ksteer: beam/antenna steering rate in azimuth [rad/s];
%   - trg: range time vector for the burst images (unique) [s];
%   - timg0: reference time for the input image (MATLAB's time vector);
%   - tazB: azimuth time vector for each burst image [s], organized as a
%       'Nb x Naz' matrix and relative to the reference time 'timg0';
%   - fdcPars: structure of Doppler centroid polynomials, see below for format;
%   - KdPars: structure of azimuth FM rate polynomials, see below for format;
%   - satSV: structure of satellite state vectors, see below for format.
%
%   Format of 'fdcPars', 'KdPars' and 'satSV'...
%
% Author: Louis-Philippe Rousseau (Universit√© Laval)
% Created: April 2018
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: add optional verbose?

% dimensions of input image data array
validateattributes( img, {'numeric'}, {'ndims', 3}, '', 'img', 1 );
[Nrg, Naz, Nb] = size( img );

% validate dimensions of time parameters in input structure
validateattributes( pars.trg, {'numeric'}, {'vector', 'numel', Nrg}, '', 'trg' );
validateattributes( pars.tazB, {'numeric'}, {'2d', 'size', [Nb, Naz]}, ...
    '', 'tazB' );

% mid-burst times (azimuth)
tBmid = pars.tazB(:,round(Naz/2));

% azimuth time vector for each burst relative to its mid-burst time
tazB = pars.tazB - tBmid;
tazB = reshape( tazB.', [1, Naz, Nb] );

% prepare structure for input satellite state vectors
Nsv = length( pars.satSV );
svTime = reshape( [pars.satSV.time], [6, Nsv] ).';
satSV.tref = svTime(1,:);
satSV.tvec = etime( svTime, satSV.tref );
satSV.pos = reshape( [pars.satSV.position], [3, Nsv] ).';
satSV.vel = reshape( [pars.satSV.velocity], [3, Nsv] ).';
clear svTime;

% ECEF satellite speed at mid-burst times
satSVmid = interpStateVectors( satSV, tBmid );
vs = sqrt( sum( satSVmid.vel.^2, 2 ) );
clear satSVmid;

% Doppler centroid rate due to azimuth scanning
Ks = 2 * vs.' / pars.wl * pars.Ksteer;

% find closest Doppler centroid polynomial to each burst image
Nfdc = length( pars.fdcPars );
fdcTime = reshape( [pars.fdcPars.azimuthTime], [6, Nfdc] ).';
fdcTimeRel = etime( fdcTime, pars.timg0 );
[~, fdcIdx] = min( abs( tBmid - fdcTimeRel.' ), [], 2 );
fdcParsB = pars.fdcPars(fdcIdx);
clear fdcTime fdcTimeRel fdcIdx;

% find closest azimuth FM rate polynomial to each burst image
Nkd = length( pars.KdPars );
KdTime = reshape( [pars.KdPars.azimuthTime], [6, Nkd] ).';
KdTimeRel = etime( KdTime, pars.timg0 );
[~, KdIdx] = min( abs( tBmid - KdTimeRel.' ), [], 2 );
KdParsB = pars.KdPars(KdIdx);
clear KdTime KdTimeRel KdIdx;

% Doppler centroid and azimuth FM rate vectors for each burst image
fdc = zeros( Nrg, Nb );
Kd = zeros( Nrg, Nb );
for nb = 1:Nb
    fdc(:,nb) = polyval( fliplr( fdcParsB(nb).dataDcPolynomial ), ...
        pars.trg - fdcParsB(nb).t0 );
    Kd(:,nb) = polyval( fliplr( KdParsB(nb).azimuthFmRatePolynomial ), ...
        pars.trg - KdParsB(nb).t0 );
end
clear fdcParsB KdParsB;

% Doppler centroid rate in TOPS SLC burst data
%fdcRate = bsxfun( @rdivide, Ks, 1 - bsxfun( @rdivide, Ks, Kd ) );
fdcRate = Ks ./ ( 1 - Ks ./ Kd );
fdcRate = reshape( fdcRate, [Nrg, 1, Nb] );

% vector of Doppler centroid time for each burst image
tdc = -fdc ./ Kd;
clear Kd;

% reference zero-Doppler time for each burst
%tBref = bsxfun( @minus, tdc, tdc(1,:) );
tBref = tdc - tdc(1,:);
%tBref = tdc;
tBref = reshape( tBref, [Nrg, 1, Nb] );
clear tdc;

% phase ramp for Doppler centroid
fdc = reshape( fdc, [Nrg, 1, Nb] ); % reshape Doppler centroid matrix
phaDC = -2 * pi * fdc .* ( tazB - tBref );
%phaDC = -2 * pi * fdc .* ( tazB );
clear fdc;

% TOPS deramping phase for each burst
%phaDeramp = -pi * bsxfun( @times, fdcRate, bsxfun( @minus, tazB, tBref ).^2 );
phaDeramp = -pi * fdcRate .* ( tazB - tBref ).^2;
clear fdcRate tBref tazB;

% apply TOPS deramping to each burst image
imgDeramp = img .* exp( 1j * phaDeramp ) .* exp( 1j * phaDC );
clear img phaDeramp phaDC;

